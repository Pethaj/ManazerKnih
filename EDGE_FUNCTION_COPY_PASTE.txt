// supabase/functions/sync-feed-2/index.ts
// Edge Function pro synchronizaci Product Feed 2 z BEWIT
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { XMLParser } from "npm:fast-xml-parser";

// === ENV VARIABLES ===
const FEED_URL = "https://bewit.love/feed/bewit?auth=xr32PRbrs554K";
const SUPABASE_URL = Deno.env.get("SB_URL");
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SB_SERVICE_ROLE_KEY");
const N8N_WEBHOOK_URL = "https://n8n.srv980546.hstgr.cloud/webhook/3890ccdd-d09f-461b-b409-660d477023a3";

// === XML Parser konfigurace ===
const parser = new XMLParser({
  ignoreAttributes: false,
  attributeNamePrefix: "@_",
  textNodeName: "#text",
  parseTagValue: false,
  parseAttributeValue: false,
  trimValues: true,
  processEntities: false,
  htmlEntities: false
});

// === Pomocn√© funkce ===
const nowIso = () => new Date().toISOString();

function decodeHtmlEntities(text: string): string {
  if (!text) return text;
  
  return text
    .replace(/&#x([0-9A-Fa-f]+);/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)))
    .replace(/&#(\d+);/g, (_, dec) => String.fromCharCode(parseInt(dec, 10)))
    .replace(/&quot;/g, '"')
    .replace(/&apos;/g, "'")
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&');
}

function toStr(v: any): string | null {
  if (v === undefined || v === null) return null;
  const s = String(v).trim();
  if (s === "") return null;
  return decodeHtmlEntities(s);
}

function toNum(v: any): number | null {
  if (v === undefined || v === null || v === "") return null;
  const n = Number(String(v).replace(",", "."));
  return Number.isFinite(n) ? n : null;
}

function toInt(v: any): number | null {
  if (v === undefined || v === null || v === "") return null;
  const n = parseInt(String(v), 10);
  return Number.isFinite(n) ? n : null;
}

function extractTextContent(node: any): string | null {
  if (!node) return null;
  if (typeof node === 'string') return node;
  if (node['#text']) return String(node['#text']);
  return String(node);
}

interface ProductFeed2 {
  product_code: string;
  product_name: string;
  description_short: string | null;
  description_long: string | null;
  category: string | null;
  url: string | null;
  thumbnail: string | null;
  price: number | null;
  currency: string;
  availability: number;
  in_action: number;
  sales_last_30_days: number;
  sync_status: string;
  last_sync_at: string;
}

async function sendToN8nWebhook(product: ProductFeed2): Promise<boolean> {
  try {
    if (!product.description_short && !product.description_long) {
      console.log(`‚è≠Ô∏è Produkt ${product.product_code} nem√° popisy, p≈ôeskakuji n8n webhook`);
      return true;
    }

    const payload = {
      product_code: product.product_code,
      product_name: product.product_name,
      description_short: product.description_short || "",
      description_long: product.description_long || "",
      feed_source: "feed_2",
      category: product.category || "",
      price: product.price || 0,
      url: product.url || ""
    };

    console.log(`üì§ Odes√≠l√°m na n8n webhook: ${product.product_code}`);
    
    const response = await fetch(N8N_WEBHOOK_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      console.error(`‚ùå N8N webhook error pro ${product.product_code}: ${response.status}`);
      return false;
    }

    console.log(`‚úÖ N8N webhook √∫spƒõ≈°n√Ω pro ${product.product_code}`);
    return true;
  } catch (error) {
    console.error(`‚ùå Chyba p≈ôi vol√°n√≠ n8n webhook pro ${product.product_code}:`, error);
    return false;
  }
}

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

Deno.serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    return new Response(
      JSON.stringify({ 
        ok: false, 
        error: "Chyb√≠ Supabase konfigurace (SB_URL nebo SB_SERVICE_ROLE_KEY)" 
      }),
      { 
        status: 500, 
        headers: { ...corsHeaders, "content-type": "application/json" } 
      }
    );
  }

  const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

  const { data: log } = await supabase
    .from("sync_logs")
    .insert({
      sync_type: "product_feed_2",
      status: "running",
      started_at: nowIso(),
      feed_url: FEED_URL
    })
    .select("id")
    .single();

  const logId = log?.id ?? -1;
  let processed = 0;
  let inserted = 0;
  let updated = 0;
  let failed = 0;
  let webhooksSent = 0;
  let webhooksFailed = 0;

  try {
    console.log(`‚è≥ ƒåek√°m 40 sekund, ne≈æ zaƒçnu stahovat feed (feed se mus√≠ vygenerovat)...`);
    await new Promise(resolve => setTimeout(resolve, 40000));
    
    console.log(`üîÑ Zaƒç√≠n√°m stahovat feed z: ${FEED_URL}`);
    const startDownload = Date.now();
    
    const res = await fetch(FEED_URL, {
      headers: { 
        accept: "application/xml",
        "User-Agent": "Supabase-Edge-Function/1.0"
      }
    });

    const downloadTime = ((Date.now() - startDownload) / 1000).toFixed(2);
    console.log(`‚è±Ô∏è Stahov√°n√≠ feedu trvalo: ${downloadTime}s`);

    if (!res.ok) {
      throw new Error(`HTTP ${res.status} p≈ôi stahov√°n√≠ feedu`);
    }

    const xmlText = await res.text();
    console.log(`‚úÖ Feed sta≈æen, velikost: ${xmlText.length} znak≈Ø`);
    
    if (xmlText.length < 100) {
      throw new Error(`Feed je p≈ô√≠li≈° kr√°tk√Ω (${xmlText.length} znak≈Ø), mo≈æn√° nen√≠ kompletn√≠`);
    }

    const parsed = parser.parse(xmlText);
    console.log("üìä XML parsov√°no, hled√°m ITEM elementy...");

    // Feed m√° strukturu: <DATA><ITEMS><ITEM>...</ITEM></ITEMS></DATA>
    const itemsNode = parsed?.DATA?.ITEMS?.ITEM;
    const items = itemsNode ? (Array.isArray(itemsNode) ? itemsNode : [itemsNode]) : [];
    
    console.log(`üì¶ Nalezeno ${items.length} produkt≈Ø`);

    if (items.length === 0) {
      const feedPreview = xmlText.substring(0, 500);
      console.error(`‚ùå ≈Ω√°dn√© ITEM elementy! Zaƒç√°tek feedu: ${feedPreview}`);
      throw new Error(`‚ö†Ô∏è ≈Ω√°dn√© produkty (ITEM) nenalezeny! Feed obsahuje ${xmlText.length} znak≈Ø. Zaƒç√°tek: ${feedPreview.substring(0, 200)}`);
    }

    const chunkSize = 50;
    
    for (let i = 0; i < items.length; i += chunkSize) {
      const chunk = items.slice(i, i + chunkSize);
      processed += chunk.length;

      console.log(`üîÑ Zpracov√°v√°m d√°vku ${Math.floor(i / chunkSize) + 1}/${Math.ceil(items.length / chunkSize)} (${chunk.length} produkt≈Ø)`);

      const products: ProductFeed2[] = [];

      for (const item of chunk) {
        try {
          const product_code = toStr(extractTextContent(item.ID));
          const product_name = toStr(extractTextContent(item.PRODUCTNAME));

          if (!product_code || !product_name) {
            console.warn("‚ö†Ô∏è Produkt bez ID nebo n√°zvu, p≈ôeskakuji");
            failed++;
            continue;
          }

          const description_short = toStr(extractTextContent(item.DESCRIPTION_SHORT));
          const description_long = toStr(extractTextContent(item.DESCRIPTION_LONG));
          const category = toStr(extractTextContent(item.CATEGORYTEXT));
          const url = toStr(extractTextContent(item.URL));
          const thumbnail = toStr(extractTextContent(item.THUMBNAIL));
          const price = toNum(extractTextContent(item.PRICE));
          const availability = toInt(extractTextContent(item.AVAIBILITY)) ?? 0;
          const in_action = toInt(extractTextContent(item.IN_ACTION)) ?? 0;
          const sales_last_30_days = toInt(extractTextContent(item.SALES_LAST_30_DAYS)) ?? 0;

          const product: ProductFeed2 = {
            product_code,
            product_name,
            description_short,
            description_long,
            category,
            url,
            thumbnail,
            price,
            currency: "CZK",
            availability,
            in_action,
            sales_last_30_days,
            sync_status: "success",
            last_sync_at: nowIso()
          };

          products.push(product);
        } catch (error) {
          console.error("‚ùå Chyba p≈ôi zpracov√°n√≠ produktu:", error);
          failed++;
        }
      }

      if (products.length === 0) {
        console.warn("‚ö†Ô∏è ≈Ω√°dn√© produkty k ulo≈æen√≠ v t√©to d√°vce");
        continue;
      }

      const before = Date.now();
      const { data, error } = await supabase
        .from("product_feed_2")
        .upsert(products, { onConflict: "product_code" })
        .select("id, product_code, created_at");

      if (error) {
        console.error("‚ùå Chyba p≈ôi upsert do Supabase:", error);
        failed += products.length;
        continue;
      }

      (data ?? []).forEach((r: any) => {
        const created = new Date(r.created_at).getTime();
        if (created > before - 5000) {
          inserted++;
        } else {
          updated++;
        }
      });

      console.log(`‚úÖ D√°vka ulo≈æena: ${data?.length || 0} produkt≈Ø`);

      // N8N webhooky jsou vypnut√© pro rychlej≈°√≠ synchronizaci
      // Embeddings se vytvo≈ô√≠ pozdƒõji p≈ôes separ√°tn√≠ proces
    }

    await supabase
      .from("sync_logs")
      .update({
        status: "success",
        finished_at: nowIso(),
        records_processed: processed,
        records_inserted: inserted,
        records_updated: updated,
        records_failed: failed
      })
      .eq("id", logId);

    console.log(`
‚úÖ Synchronizace Product Feed 2 dokonƒçena!
üìä Zpracov√°no: ${processed}
‚ûï Vlo≈æeno: ${inserted}
üîÑ Aktualizov√°no: ${updated}
‚ùå Selhalo: ${failed}
üì§ N8N webhooks odesl√°no: ${webhooksSent}
‚ö†Ô∏è N8N webhooks selhalo: ${webhooksFailed}
    `);

    return new Response(
      JSON.stringify({
        ok: true,
        processed,
        inserted,
        updated,
        failed,
        webhooks: {
          sent: webhooksSent,
          failed: webhooksFailed
        }
      }),
      {
        headers: { ...corsHeaders, "content-type": "application/json" }
      }
    );

  } catch (e) {
    console.error("‚ùå Kritick√° chyba p≈ôi synchronizaci:", e);
    
    await supabase
      .from("sync_logs")
      .update({
        status: "error",
        finished_at: nowIso(),
        records_processed: processed,
        records_inserted: inserted,
        records_updated: updated,
        records_failed: failed,
        error_message: String(e?.message ?? e)
      })
      .eq("id", logId);

    return new Response(
      JSON.stringify({
        ok: false,
        error: String(e?.message ?? e),
        processed,
        inserted,
        updated,
        failed
      }),
      {
        status: 500,
        headers: { ...corsHeaders, "content-type": "application/json" }
      }
    );
  }
});
